# NOTE: this file is for testing the wavetank interface.  It is not a general
# purpose script, so modifications will be necessary for more general usage.
from ctypes import (
    CDLL,
    POINTER,
    create_string_buffer,
    byref,
    c_byte,
    c_int,
    c_double,
    c_float, 
    c_char,
    c_char_p, 
    c_bool
)

import numpy as np
import numpy.typing as npt
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

from pyOpenFAST.interface_abc import OpenFASTInterfaceType
from pyOpenFAST.tdmslib import TdmsToDict 


project_root = '../../../'
library_path = project_root + '/build-Single-Debug/glue-codes/labview/libwavetanktestinglib.dylib'

def to_c_array(array: npt.NDArray, c_type: Any = c_float) -> Any:
    """Converts numpy array to C array of specified type.

    Args:
        array: Input numpy array
        c_type: C type to convert to (default: c_float)

    Returns:
        C-compatible array of the specified type
    """
    try:
        if isinstance(array, np.ndarray):
            flat_array = array.flatten()
            return (c_type * len(flat_array))(*flat_array)
        # If list/tuple, convert directly to C array
        return (c_type * len(array))(*array)
    except Exception as e:
        raise TypeError(f"Failed to convert to C array: {e}")

def to_c_string(input_array: List[str]) -> Tuple[bytes, int]:
    """Converts input string array into a null-separated byte string for use in C.

    Args:
        input_array: List of strings to join with null characters

    Returns:
        Tuple containing:
            - The encoded byte string
            - Length of the encoded string
    """
    encoded_string = '\x00'.join(input_array).encode('utf-8')
    return encoded_string, len(encoded_string)


@dataclass
class MotionData:
    """POD-style container for motion-related data i.e. state of a node."""
    pos: npt.NDArray[np.float32]           # [x,y,z,roll,pitch,yaw]
    vel: npt.NDArray[np.float32]           # [x_dot,y_dot,z_dot,roll_dot,pitch_dot,yaw_dot]
    acc: npt.NDArray[np.float32]           # [x_ddot,y_ddot,z_ddot,roll_ddot,pitch_ddot,yaw_ddot]

@dataclass
class LoadsData:
    """POD-style container for motion-related data i.e. state of a node."""
    loads: npt.NDArray[np.float32]         # [Fx,Fy,Fz,Mx,My,Mz]

#-------------------------------------------------------------------------------
# Generate a debug file
#-------------------------------------------------------------------------------
class DriverDbg:
    """
    A helper class for debugging the wavetankinterface. This class writes out all the
    input positions/orientations, velocities, accelerations, and the resulting
    forces and moments at the platform mesh point. If functioning correctly, this
    will be identical to the corresponding values in the wavetank o utput
    channels.

    NOTE: This may not output everything in the interface as updates have been made
    since writing this, but this routine was not updated accordingly.
    """

    def __init__(self, filename: str) -> None:
        """Initializes the debugging class and open the output file."""
        self.filename = filename
        self.opened = True

        with open(filename, 'wt') as self.debug_file:
            self._write_header()

        self.debug_file = open(filename, 'at') # switch to append mode

    def _write_header(self) -> None:
        """Writes the header information to the debug file."""
        # Build header components
        timestamp = datetime.now().strftime('%b-%d-%Y %H:%M:%S')
        header_lines = [
            f"## This file was generated by wavetank_c_lib on {timestamp}",
            f"## This file contains the resulting forces/moments at the referenc mesh point passed into the adi_c_lib",
            "#",
            "#",
            "#",
            "#"
        ]

        # Write column headers
        column_names = ["Time"]
        column_units = ["(s)"]
        # Position columns
        for suffix in ["x", "y", "z"]:
            column_names.append(f"{suffix}")
            column_units.append("(m)")
        # orientation columns
        for suffix in ["phi", "theta", "psi"]:
            column_names.append(f"{suffix}")
            column_units.append("(rad)")
        # Velocity columns
        for suffix in ["Vx", "Vy", "Vz"]:
            column_names.append(f"{suffix}")
            column_units.append("(m/s)")
        # Angular velocity columns
        for suffix in ["RVx", "RVy", "RVz"]:
            column_names.append(f"{suffix}")
            column_units.append("(rad/s)")
        # Acceleration columns
        for suffix in ["Ax", "Ay", "Az"]:
            column_names.append(f"{suffix}")
            column_units.append("(m/s^2)")
        # Angular acceleration columns
        for suffix in ["RAx", "RAy", "RAz"]:
            column_names.append(f"{suffix}")
            column_units.append("(rad/s^2)")
        # Force columns
        for suffix in ["Fx", "Fy", "Fz"]:
            column_names.append(f"{suffix}")
            column_units.append("(N)")
        # Moment columns
        for suffix in ["Mx", "My", "Mz"]:
            column_names.append(f"{suffix}")
            column_units.append("(N-m)")

        f_string = "{:^25s}"
        header_lines.append("".join([f_string.format(name) for name in column_names]))
        header_lines.append("".join([f_string.format(unit) for name, unit in zip(column_names, column_units)]))

        self.debug_file.write("\n".join(header_lines) + "\n")

    def write(
        self,
        t: float,
        body_motion: MotionData,
        body_loads:  LoadsData,
    ) -> None:
        """Writes the current state to the debug file."""
        row_data = [f"{t:10.4f}"]

        row_data.extend([f"{val:25.7e}" for val in body_motion.pos[:]])
        row_data.extend([f"{val:25.7e}" for val in body_motion.vel[:]])
        row_data.extend([f"{val:25.7e}" for val in body_motion.acc[:]])
        row_data.extend([f"{val:25.7e}" for val in body_loads.loads[:]])

        self.debug_file.write("".join(row_data) + "\n")
        self.debug_file.flush()

    def end(self) -> None:
        """Closes the debug file."""
        if self.opened:
            self.debug_file.close()
            self.opened = False



class WaveTankLib(OpenFASTInterfaceType):

    #--------------------------------------
    # Error levels
    #--------------------------------------
    error_levels: Dict[int, str] = {
        0: "None",
        1: "Info",
        2: "Warning",
        3: "Severe Error",
        4: "Fatal Error"
    }

    # Debug output file: When coupled into another code, an array of position/orientation,
    # velocities, and accelerations are passed in, and an array of Forces + Moments is
    # returned. For debugging, it may be useful to dump all off this to a file.
    debug_output_file: str = "DbgOutputs.out"
    debug_outputs: int = 1         # For checking the interface, set this to 1

    #--------------------------------------
    # Constants
    #--------------------------------------
    # NOTE: The length of the error message in Fortran is determined by the
    #       ErrMsgLen variable in the NWTC_Base.f90 file. If ErrMsgLen is modified,
    #       the corresponding size here must also be updated to match.
    ERROR_MESSAGE_LENGTH: int = 8197
    DEFAULT_STRING_LENGTH: int = 1025

    def __init__(self, library_path: str, input_file_names: dict):
        """

        Args:
            library_path (str): Path to the compile wavetank interface shared library
            input_file_names (dict): Map of file names for each included module:
                - WT_InputFile
        """
        super().__init__(library_path)

        # Create C-compatible string buffers for input file names
        self.input_file_names = {
            k: create_string_buffer(str(Path(v).absolute()).encode('utf-8'), self.IntfStrLen)
            for k,v in input_file_names.items()
        }

        self._initialize_routines()

        self.ended = False   # For error handling at end
        self.print_error_level = 1


        # Error handling setup
        self.abort_error_level = 4
        self.error_status_c = c_int(0)
        self.error_message_c = create_string_buffer(self.ERROR_MESSAGE_LENGTH)

        # returned values
        self.rootname_c = create_string_buffer(self.IntfStrLen)
        self.vtkdir_c   = create_string_buffer(self.IntfStrLen)
        self.buoyWaveElev_c = c_float(0)        # wave elevation at buoy

    def _initialize_routines(self):
        self.WaveTank_Init.argtypes = [
            POINTER(c_char),        #  intent(in   ) :: WT_InputFile_c(IntfStrLen)
            POINTER(c_char),        #  intent(  out) :: RootName_C(IntfStrLen)
            POINTER(c_char),        #  intent(  out) :: VTKdir_C(IntfStrLen)
            POINTER(c_int),         #  intent(  out) :: ErrStat_C
            POINTER(c_char),        #  intent(  out) :: ErrMsg_C(ErrMsgLen_C)
        ]
        self.WaveTank_Init.restype = None

        self.WaveTank_CalcStep.argtypes = [
            POINTER(c_double),      # real(c_double) :: time
            POINTER(c_float),       # intent(in   ) :: pos(6)
            POINTER(c_float),       # intent(in   ) :: vel(6)
            POINTER(c_float),       # intent(in   ) :: acc(6)
            POINTER(c_float),       # intent(  out) :: FrcMom(6)
            POINTER(c_float),       # intent(  out) :: buoyWaveElev
            POINTER(c_int),         # integer(c_int),         intent(  out) :: ErrStat_C
            POINTER(c_char),        # character(kind=c_char), intent(  out) :: ErrMsg_C(ErrMsgLen_C)
        ]
        self.WaveTank_CalcStep.restype = None

        self.WaveTank_End.argtypes = [
            POINTER(c_int),         # integer(c_int),         intent(  out) :: ErrStat_C
            POINTER(c_char),        # character(kind=c_char), intent(  out) :: ErrMsg_C(ErrMsgLen_C)
        ]
        self.WaveTank_End.restype = c_int

        self.WaveTank_SetWaveFieldPointer.argtypes = [
            POINTER(c_int),         # integer(c_int),         intent(  out) :: ErrStat_C
            POINTER(c_char),        # character(kind=c_char), intent(  out) :: ErrMsg_C(ErrMsgLen_C)
        ]
        self.WaveTank_SetWaveFieldPointer.restype = None


    def check_error(self) -> None:
        """Checks for and handles any errors from the Fortran library.

        Raises:
            RuntimeError: If a fatal error occurs in the Fortran code
        """
        # If the error status is 0, return
        if self.error_status_c.value == 0:
            return

        # Get the error level and error message
        error_level = self.error_levels.get(
            self.error_status_c.value,
            f"Unknown Error Level: {self.error_status_c.value}"
        )
        error_msg = self.error_message_c.raw.decode('utf-8').strip()
        message = f"WaveTank library {error_level}: {error_msg}"
        # If the error level is fatal, call WaveTank_End() and raise an error
        if self.error_status_c.value >= self.abort_error_level:
            try:
                self.WaveTank_End(
                    byref(self.error_status_c),             # OUT <- error status code
                    self.error_message_c                    # OUT <- error message buffer
                )
                if self.error_status_c.value == 4:
                    error_msg = self.error_message_c.raw.decode('utf-8').strip()
                    print(f'WaveTank_End error: {error_msg}')
            except Exception as e:
                message += f"\nAdditional error during cleanup: {e}"
            raise RuntimeError(message)
        else:
            print(message)


    def _validate_loads_data(
        self,
        loads: LoadsData,
        name: str,
    ) -> None:
        """Validates motion data dimensions.

        Args:
            motion: Motion data to validate
            name: Name of the component for error messages

        Raises:
            ValueError: If dimensions are incorrect
        """
        expected_shape = 6

        if loads.loads.shape[0] != expected_shape:
            raise ValueError(
                f"{name} loads must have shape {expected_shape}, "
                f"got {loads.loads.shape}"
            )


    def _validate_motion_data(
        self,
        motion: MotionData,
        name: str,
    ) -> None:
        """Validates motion data dimensions.

        Args:
            motion: Motion data to validate
            name: Name of the component for error messages

        Raises:
            ValueError: If dimensions are incorrect
        """
        expected_shape = 6

        if motion.pos.shape[0] != expected_shape:
            raise ValueError(
                f"{name} position must have shape {expected_shape}, "
                f"got {motion.pos.shape}"
            )

        if motion.vel.shape[0] != expected_shape:
            raise ValueError(
                f"{name} velocity must have shape {expected_shape}, "
                f"got {motion.vel.shape}"
            )

        if motion.acc.shape[0] != expected_shape:
            raise ValueError(
                f"{name} acceleration must have shape {expected_shape}, "
                f"got {motion.acc.shape}"
            )

    def _prepare_motion_arrays(
        self,
        body: MotionData,
    ) -> Dict[str, Any]:
        """Prepares C-compatible arrays for motion data.

        Args:
            body: body motion data

        Returns:
            Dictionary containing all prepared C arrays
        """
        return {
            # body data
            'body_pos_c': to_c_array(body.pos, c_float),
            'body_vel_c': to_c_array(body.vel, c_float),
            'body_acc_c': to_c_array(body.acc, c_float),
        }



    def init(self):
        _error_message = create_string_buffer(self.ERROR_MSG_C_LEN)

        # # Convert the initial positions array into c_float array
        # init_positions_c = (c_float * 6)(0.0, )
        # for i, p in enumerate(platform_init_pos):
        #     init_positions_c[i] = c_float(p)

        self.WaveTank_Init(
            self.input_file_names["WaveTank"],
            self.rootname_c,                        # OUT <- rootname of output files
            self.vtkdir_c,                          # OUT <- directory for vtk output
            byref(self.error_status_c),             # OUT <- error status code
            self.error_message_c                    # OUT <- error message buffer
        )
        self.check_error()
        # tmp = self.rootname_c.raw.decode('utf-8').strip()
        # print(f'RootName_c: {tmp}')
        # tmp = self.vtkdir_c.raw.decode('utf-8').strip()
        # print(f'VTKdir_c: {tmp}')

    def calc_step(
        self,
        time: float,
        body_motion: MotionData,
        body_loads:  LoadsData,
    ):
        self._validate_motion_data(body_motion, "body")
        self._validate_loads_data(body_loads, "body")

        # loads storage
        #tmp_loads_c=np.array([0, 0, 0, 0, 0, 0], dtype=c_float)
        tmp_loads_c = (c_float * (6))(0.)

        # Convert data to C arrays
        motion_arrays = self._prepare_motion_arrays(body_motion)

        self.WaveTank_CalcStep(
            byref(c_double(time)),
            motion_arrays['body_pos_c'],            # IN -> body pos [x,y,z,roll,pitch,yaw]
            motion_arrays['body_vel_c'],            # IN -> body vel [TVx, TVy, TVz, RVx, RVy, RVz]
            motion_arrays['body_acc_c'],            # IN -> body acc [TAx, TAy, TAz, RAx, RAy, RAz]
            tmp_loads_c,                            # OUT <- body forces and moments [Fx,Fy,Fz,Mx,My,Mz]
            byref(self.buoyWaveElev_c),             # OUT <- buoy wave elevation
            byref(self.error_status_c),             # OUT <- error status code
            self.error_message_c                    # OUT <- error message buffer
        )
        self.check_error()

        # Copy over loads
        body_loads.loads = np.ctypeslib.as_array(tmp_loads_c).astype(np.float32).copy()
        #print(f"body_loads.loads {body_loads.loads}")

 
    def end(self) -> None:
        self.WaveTank_End(
            byref(self.error_status_c),             # OUT <- error status code
            self.error_message_c                    # OUT <- error message buffer
        )
        self.check_error()


if __name__=="__main__":

    # Read a motion series from a prior tank run
    TDMSfile="0822_4.tdms"
    floater_motions = TdmsToDict(TDMSfile)["Winch System"]

    n_timesteps = len(floater_motions["x"])
    dt = 0.01   # seconds

    wavetanklib = WaveTankLib(
        library_path,
        {
            "WaveTank":   "wavetankconfig.in",
        },
    )
    wavetanklib.init()

    # output everything going through interface
    if wavetanklib.debug_outputs:
        debug_output_file = DriverDbg(
            wavetanklib.debug_output_file
        )


 
    for i in range(n_timesteps):

        time = dt*i

        # position/orientation
        x=floater_motions["x"][i]
        y=floater_motions["y"][i]
        z=floater_motions["z"][i]
        r=floater_motions["phi"][i]
        p=floater_motions["theta"][i]
        y=floater_motions["psi"][i]
        pos = np.array([x, y, z, r, p, y], dtype=np.float32)

        # vel 
        x_dot=floater_motions["x_dot"][i]
        y_dot=floater_motions["y_dot"][i]
        z_dot=floater_motions["z_dot"][i]
        r_dot=floater_motions["phi_dot"][i]
        p_dot=floater_motions["theta_dot"][i]
        y_dot=floater_motions["psi_dot"][i]
        vel = np.array([x_dot, y_dot, z_dot, r_dot, p_dot, y_dot], dtype=np.float32)

        # acc 
        x_ddot=floater_motions["x_ddot"][i]
        y_ddot=floater_motions["y_ddot"][i]
        z_ddot=floater_motions["z_ddot"][i]
        r_ddot=floater_motions["phi_ddot"][i]
        p_ddot=floater_motions["theta_ddot"][i]
        y_ddot=floater_motions["psi_ddot"][i]
        acc = np.array([x_ddot, y_ddot, z_ddot, r_ddot, p_ddot, y_ddot], dtype=np.float32)

        #vel=pos
        #acc=pos
        body_motion=MotionData(pos,vel,acc)
        body_loads=LoadsData(np.array([0, 0, 0, 0, 0, 0], dtype=np.float32))

        wavetanklib.calc_step(
            time,
            body_motion,
            body_loads,
        )

        # Write debug output if enabled
        if wavetanklib.debug_outputs:
            debug_output_file.write(
                time, body_motion, body_loads
            )



    # Close debug output file if it was opened
    if wavetanklib.debug_outputs:
        debug_output_file.end()


    wavetanklib.end()

    print("WaveTank run completed")


